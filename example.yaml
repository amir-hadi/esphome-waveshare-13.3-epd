esphome:
  name: photo-frame
  friendly_name: Photo Frame
  project:
    name: ahadi.epd_photo_frame
    version: 1.0.0
  on_boot:
    priority: -100
    then:
      - wait_until:
          condition: wifi.connected
          timeout: 30s
      - wait_until:
          condition:
            time.has_time:
              id: sntp_time
          timeout: 30s
      - wait_until:
          condition: api.connected
          timeout: 20s
      # Start background download and wait for success
      - lambda: |-
          id(epd_display).startDownload();
      - wait_until:
          condition:
            binary_sensor.is_on: dl_ok
          timeout: 180s
      - if:
          condition:
            binary_sensor.is_on: dl_ok
          then:
            - lambda: |-
                id(epd_display).displayFromFile();
      # Power off display before deep sleep
      - lambda: |-
          id(epd_display).sleepDisplay();
      - delay: 200ms
      # Wait briefly for HA to push next wake epoch
      - wait_until:
          condition:
            lambda: |-
              auto now = id(sntp_time).now();
              if (!now.is_valid()) return false;
              return ((int32_t) id(wake_epoch).state) > now.timestamp;
          timeout: 10s
      # Sleep for configured minutes (from number.wake_interval_minutes)
      - deep_sleep.enter:
          id: epd_sleep
          sleep_duration: !lambda |-
            float mins = id(wake_interval_minutes).state;
            if (mins < 0.0167f) mins = 1.0f;  // min 1s fallback
            if (mins > (30.0f * 24.0f * 60.0f)) mins = (30.0f * 24.0f * 60.0f);  // clamp 30d
            return (uint32_t)(mins * 60.0f * 1000.0f);

esp32:
  board: esp32dev
  framework:
    type: esp-idf
  # Use custom partitions with SPIFFS (single app + spiffs large)
  partitions: partitions.csv

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "o/UlT22K9GgWOo6lOChF+bMMvAWnsWctPv3b/abIUCc="
  services:
    - service: set_image_url
      variables:
        url: string
      then:
        - lambda: |-
            id(epd_display).setImageUrl(std::string(url));
    - service: download_image
      then:
        - lambda: 'id(epd_display).startDownload();'
    - service: display_image
      then:
        - lambda: 'id(epd_display).displayFromFile();'

ota:
  - platform: esphome
    password: "b90f12e39aade3f5a99cc36c909af902"

# Time sync for scheduling sleep-until
time:
  - platform: sntp
    id: sntp_time

# Native ESPHome datetime picker (renders in HA UI)
datetime:
  - platform: template
    type: datetime
    id: wake_datetime
    name: "EPD Wake At"
    time_id: sntp_time
    optimistic: true

# Manual deep sleep control (sleep only when triggered)
deep_sleep:
  id: epd_sleep
  # wakeup_pin: GPIO32
  # wakeup_pin_mode: IGNORE

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Photo-Frame Fallback Hotspot"
    password: "Pvwqos4MOApr"

external_components:
  # - source: github://amir-hadi/esphome-waveshare-13.3-epd@main
  #   components: [ epd_photo_frame ]
  - source:
      type: local
      path: components
    components: [ epd_photo_frame ]

captive_portal:

# Enable SPI
spi:
  clk_pin: GPIO13
  mosi_pin: GPIO14
  miso_pin: GPIO19

# Your EPD Photo Frame component
display:
  - platform: epd_photo_frame
    id: epd_display
    reset_pin: GPIO26
    dc_pin: GPIO27
    busy_pin: GPIO25
    power_pin: GPIO33
    cs_master_pin: GPIO18
    cs_slave_pin: GPIO22
    image_url: "http://10.0.0.253:8080/image.bin"
    update_interval: 30min
    download_success:
      id: dl_ok
      name: "EPD Download Success"
      entity_category: diagnostic

    download_bytes:
      id: dl_bytes
      name: "EPD Download Bytes"
      entity_category: diagnostic

    download_status:
      id: dl_status
      name: "EPD Download Status"
      entity_category: diagnostic

# Scheduling knobs
number:
  - platform: template
    id: wake_interval_minutes
    name: "EPD Wake Interval (min)"
    min_value: 1
    max_value: 1440
    step: 1
    optimistic: true
    entity_category: config
    initial_value: 1440
    restore_value: true
  - platform: template
    id: wake_epoch
    name: "EPD Wake Epoch (s)"
    min_value: 0
    max_value: 4102444800
    step: 1
    optimistic: true
    entity_category: config

button:
  - platform: template
    name: "EPD Download Image"
    icon: mdi:download
    on_press:
      then:
        - lambda: |-
            id(epd_display).startDownload();

  - platform: template
    name: "EPD Refresh From File"
    icon: mdi:image-refresh
    on_press:
      then:
        - lambda: |-
            id(epd_display).displayFromFile();

  - platform: template
    id: epd_sleep_interval_btn
    name: "EPD Sleep (Interval)"
    icon: mdi:sleep
    on_press:
      then:
        - deep_sleep.enter:
            id: epd_sleep
            sleep_duration: !lambda |-
              float mins = id(wake_interval_minutes).state;
              if (mins < 0.0167f) mins = 0.0167f;  // >= 1s
              return (uint32_t)(mins * 60.0f * 1000.0f);

  - platform: template
    id: epd_sleep_until_epoch_btn
    name: "EPD Sleep (Until Epoch)"
    icon: mdi:calendar-clock
    on_press:
      then:
        - deep_sleep.enter:
            id: epd_sleep
            sleep_duration: !lambda |-
              auto now = id(sntp_time).now();
              if (!now.is_valid()) return (uint32_t)60000; // 60s fallback
              int64_t diff_s = (int64_t) id(wake_epoch).state - (int64_t) now.timestamp;
              if (diff_s < 1) diff_s = 1;
              if (diff_s > 3600LL*24LL*30LL) diff_s = 3600LL*24LL*30LL; // clamp 30 days
              return (uint32_t)(diff_s * 1000ULL);

  - platform: template
    name: "EPD Sleep (Until Picker)"
    icon: mdi:calendar-range
    on_press:
      then:
        - deep_sleep.enter:
            id: epd_sleep
            sleep_duration: !lambda |-
              auto now = id(sntp_time).now();
              if (!now.is_valid()) return (uint32_t)60000; // 60s fallback
              auto tgt = id(wake_datetime).state_as_esptime();
              // If picker not set, default 60s
              if (tgt.year == 0) return (uint32_t)60000;
              int64_t diff_s = (int64_t) tgt.timestamp - (int64_t) now.timestamp;
              if (diff_s < 1) diff_s = 1;
              if (diff_s > 3600LL*24LL*30LL) diff_s = 3600LL*24LL*30LL; // clamp 30 days
              return (uint32_t)(diff_s * 1000ULL);

binary_sensor:
  - platform: status
    id: epd_status
    name: "Photo Frame Status"   # must set a name so HA exposes it

# Lightweight web server to accept binary uploads
web_server:
  port: 80
  include_internal: true

## Optional: Add a text sensor to show current image URL (commented to keep build minimal)
# text_sensor:
#   - platform: custom
#     lambda: |-
#       auto url_sensor = new esphome::text_sensor::TextSensor();
#       url_sensor->publish_state(id(epd_display).getImageUrl());
#       return {url_sensor};
#     text_sensors:
#       - name: "Current Image URL"
#         id: current_image_url